"use strict";(self.webpackChunkfig_documentation=self.webpackChunkfig_documentation||[]).push([[4980],{8329:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"overview/comparison-to-alternatives","title":"Comparison To Alternatives","description":"Modern dotnet applications might be configured to draw from a range of different configuration providers. This provides a lot of flexibility but can also be confusing for those configuring the application. Fig is also a configuration provider and as such, can work along side other configuration sources. However, fig is more than just a configuration provider. It is a complete solution for managing settings across multiple micro-services. This is because when an application starts up, it registers its configuration with Fig meaning those settings are now viewable and editable from within the Fig web application.","source":"@site/docs/overview/comparison-to-alternatives.md","sourceDirName":"overview","slug":"/overview/comparison-to-alternatives","permalink":"/docs/next/overview/comparison-to-alternatives","draft":false,"unlisted":false,"editUrl":"https://github.com/mzbrau/fig/tree/main/doc/fig-documentation/docs/overview/comparison-to-alternatives.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Architecture","permalink":"/docs/next/overview/architecture"},"next":{"title":"Features","permalink":"/docs/next/category/features"}}');var r=n(4848),t=n(8453);const o={sidebar_position:3},a="Comparison To Alternatives",l={},c=[{value:"Cloud Configuration Services",id:"cloud-configuration-services",level:2},{value:"AWS Systems Manager Parameter Store",id:"aws-systems-manager-parameter-store",level:3},{value:"Azure App Configuration",id:"azure-app-configuration",level:3},{value:"Google Cloud Secret Manager",id:"google-cloud-secret-manager",level:3},{value:"Open Source Alternatives",id:"open-source-alternatives",level:2},{value:"Consul by HashiCorp",id:"consul-by-hashicorp",level:3},{value:"etcd",id:"etcd",level:3},{value:"Apache Zookeeper",id:"apache-zookeeper",level:3},{value:"Traditional Configuration Methods",id:"traditional-configuration-methods",level:2},{value:"JSON/XML Configuration Files",id:"jsonxml-configuration-files",level:3},{value:"Environment Variables",id:"environment-variables",level:3},{value:"When to Choose Fig",id:"when-to-choose-fig",level:2}];function d(e){const i={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"comparison-to-alternatives",children:"Comparison To Alternatives"})}),"\n",(0,r.jsx)(i.p,{children:"Modern dotnet applications might be configured to draw from a range of different configuration providers. This provides a lot of flexibility but can also be confusing for those configuring the application. Fig is also a configuration provider and as such, can work along side other configuration sources. However, fig is more than just a configuration provider. It is a complete solution for managing settings across multiple micro-services. This is because when an application starts up, it registers its configuration with Fig meaning those settings are now viewable and editable from within the Fig web application."}),"\n",(0,r.jsx)(i.h2,{id:"cloud-configuration-services",children:"Cloud Configuration Services"}),"\n",(0,r.jsx)(i.h3,{id:"aws-systems-manager-parameter-store",children:"AWS Systems Manager Parameter Store"}),"\n",(0,r.jsx)(i.p,{children:"AWS Systems Manager Parameter Store is a popular choice for storing configuration data and secrets in AWS environments."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Why Fig is Better:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Rich Web UI"}),": Fig provides a comprehensive web interface for managing settings, while Parameter Store relies on the AWS Console which lacks specialized configuration management features"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Real-time Updates"}),": Fig pushes configuration changes to applications instantly without requiring application restarts or polling"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Type Safety"}),": Fig provides strongly-typed configuration with validation, while Parameter Store treats all values as strings"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Cross-Environment Management"}),": Fig can manage configurations across multiple environments and cloud providers, not just AWS"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Audit Trail"}),": Fig provides detailed change history with user attribution, timestamps, and change descriptions"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"No Vendor Lock-in"}),": Fig can be deployed anywhere, while Parameter Store ties you to AWS infrastructure"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"azure-app-configuration",children:"Azure App Configuration"}),"\n",(0,r.jsx)(i.p,{children:"Azure App Configuration is Microsoft's cloud-native configuration service for Azure applications."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Why Fig is Better:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Specialized .NET Integration"}),": Fig is built specifically for .NET applications and integrates seamlessly with the existing .NET configuration system"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Advanced Features"}),": Fig includes features like lookup tables, custom validation scripts, dependent settings, and scheduled changes that App Configuration lacks"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Multi-tenancy Support"}),": Fig supports multiple instances and client overrides out of the box"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Self-hosted Option"}),": Fig can be deployed on-premises or in any cloud, while App Configuration is Azure-only"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Cost Effectiveness"}),": Fig eliminates per-request charges and provides unlimited configuration reads"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Enhanced Security"}),": Fig encrypts all values at rest and provides granular access control with user classifications"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"google-cloud-secret-manager",children:"Google Cloud Secret Manager"}),"\n",(0,r.jsx)(i.p,{children:"Google Cloud Secret Manager focuses primarily on secrets management with some configuration capabilities."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Why Fig is Better:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Configuration-First Design"}),": Fig is designed specifically for application configuration, not just secrets"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Interactive Management"}),": Fig provides an intuitive web interface for configuration management, while Secret Manager is primarily API/CLI driven"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Live Monitoring"}),": Fig shows real-time client status and health checks, providing visibility into which services are running and their configuration state"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Rich Data Types"}),": Fig supports complex data types like data grids, nested objects, and custom validation, while Secret Manager is limited to key-value pairs"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Change Management"}),": Fig includes features like scheduled changes, change approval workflows, and rollback capabilities"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"open-source-alternatives",children:"Open Source Alternatives"}),"\n",(0,r.jsx)(i.h3,{id:"consul-by-hashicorp",children:"Consul by HashiCorp"}),"\n",(0,r.jsx)(i.p,{children:"Consul provides service discovery and configuration management capabilities."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Why Fig is Better:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Specialized .NET Support"}),": Fig integrates natively with .NET's configuration system, while Consul requires custom integration work"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"User-Friendly Interface"}),": Fig provides a purpose-built web UI for configuration management, while Consul's UI is primarily focused on service discovery"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Configuration Validation"}),": Fig includes built-in validation, type checking, and custom validation scripts"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Simpler Deployment"}),": Fig has fewer infrastructure requirements compared to Consul's cluster setup"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Rich Feature Set"}),": Fig includes advanced features like time machine (configuration history), scheduled changes, and custom actions"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"No Programming Required"}),": Fig allows non-technical users to manage configurations through its web interface"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"etcd",children:"etcd"}),"\n",(0,r.jsx)(i.p,{children:"etcd is a distributed key-value store often used for configuration in Kubernetes environments."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Why Fig is Better:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Higher-Level Abstraction"}),": Fig provides configuration management at the application level rather than raw key-value storage"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Web Interface"}),": Fig includes a comprehensive web UI, while etcd requires separate tools for visualization"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Type Safety and Validation"}),": Fig ensures configuration correctness with type checking and validation rules"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"User Management"}),": Fig includes built-in user authentication and authorization"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Configuration Documentation"}),": Fig allows inline documentation and descriptions for each setting"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Change Tracking"}),": Fig provides detailed audit trails and change history"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"apache-zookeeper",children:"Apache Zookeeper"}),"\n",(0,r.jsx)(i.p,{children:"Zookeeper is a centralized service for maintaining configuration information and distributed synchronization."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Why Fig is Better:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Modern Architecture"}),": Fig uses contemporary web technologies and RESTful APIs, while Zookeeper uses older protocols"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Ease of Use"}),": Fig provides a user-friendly web interface compared to Zookeeper's command-line tools"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Configuration-Specific Features"}),": Fig includes features designed specifically for application configuration management"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Better Monitoring"}),": Fig provides real-time client monitoring and health checks"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Simplified Operations"}),": Fig requires less operational overhead and complexity than maintaining a Zookeeper ensemble"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"traditional-configuration-methods",children:"Traditional Configuration Methods"}),"\n",(0,r.jsx)(i.h3,{id:"jsonxml-configuration-files",children:"JSON/XML Configuration Files"}),"\n",(0,r.jsx)(i.p,{children:"Traditional file-based configuration stored in version control."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Why Fig is Better:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Live Updates"}),": Fig allows configuration changes without application restarts or redeployments"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Centralized Management"}),": Manage all microservice configurations from a single interface"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Environment Management"}),": Easily manage different configurations across environments without code changes"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Access Control"}),": Fig provides user-based access control, while files rely on filesystem permissions"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Change Validation"}),": Fig validates changes before applying them, preventing configuration errors"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Audit Trail"}),": Complete history of who changed what and when"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"environment-variables",children:"Environment Variables"}),"\n",(0,r.jsx)(i.p,{children:"Using environment variables for configuration management."}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Why Fig is Better:"})}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Rich Data Types"}),": Fig supports complex data structures, not just string values"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Runtime Changes"}),": Update configurations without restarting applications or containers"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Centralized Visibility"}),": See all configurations across all services in one place"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Validation and Documentation"}),": Fig provides validation rules and documentation for each setting"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Change Management"}),": Track changes with timestamps, user information, and change descriptions"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Security"}),": Fig encrypts sensitive values and provides granular access control"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"when-to-choose-fig",children:"When to Choose Fig"}),"\n",(0,r.jsx)(i.p,{children:"Consider Fig if your solution:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Is comprised of multiple .NET applications or services requiring settings"}),"\n",(0,r.jsx)(i.li,{children:"Requires frequent configuration changes across different environments"}),"\n",(0,r.jsx)(i.li,{children:"Benefits from a centralized configuration management interface"}),"\n",(0,r.jsx)(i.li,{children:"Needs strong type safety and validation for configuration values"}),"\n",(0,r.jsx)(i.li,{children:"Requires detailed audit trails and change management"}),"\n",(0,r.jsx)(i.li,{children:"Values operational simplicity and reduced deployment complexity"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Do not consider Fig if your solution:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Is not .NET based"}),"\n",(0,r.jsx)(i.li,{children:"Has minimal or static configuration requirements"}),"\n",(0,r.jsx)(i.li,{children:"Is a single application with rarely-changing settings"}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var s=n(6540);const r={},t=s.createContext(r);function o(e){const i=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);